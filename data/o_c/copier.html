<html class="no-js">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 16.1), see www.w3.org">
  <meta charset="utf-8">

  <title></title>
  <meta name="description" content="">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1, minimal-ui">
  <meta http-equiv="cleartype" content="on">
  <link rel="stylesheet" href="o_c.css" type="text/css">
</head>

<body>
  <div class="centered">
    <div class="content">
		<h2 id="copiermaschine">CopierMaschine</h2>
		<p><img src="./copier.svg" alt="copiermaschine" class="img-responsive"></p>

<div class = "info">
<h3 id="inputs-and-outputs">Inputs and outputs</h3>

<table class="settings-table">
  <thead>
    <tr>
      <th>I/O</th>
      <th>Function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TR1</td>
      <td>Clock input</td>
    </tr>
    <tr>
      <td>TR2</td>
      <td>Hold ( = freeze ring buffer)</td>
    </tr>
    <tr>
      <td>TR3</td>
      <td>Transpose: Octave up, when high</td>
    </tr>
    <tr>
      <td>TR4</td>
      <td>Transpose: Octave down, when high (overridden by TR3)</td>
    </tr>
    <tr>
      <td>CV1</td>
      <td>Sample in</td>
    </tr>
    <tr>
      <td>CV2</td>
      <td>Index: ring buffer index (= “delay”)</td>
    </tr>
    <tr>
      <td>CV3</td>
      <td>Mask: rotate scale mask</td>
    </tr>
    <tr>
      <td>CV4</td>
      <td>assignable: octave, root, transpose (by scale-degrees), buffer-length, or CV input scaling</td>
    </tr>
    <tr>
      <td>A, B, C, D</td>
      <td>ASR outputs 1-4</td>
    </tr>
  </tbody>
</table>

<h3 id="controls">Controls</h3>

<table class="settings-table">
  <thead>
    <tr>
      <th>Control</th>
      <th>Function</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Left encoder (turn)</td>
      <td>Select scale in main menu; move cursor in scale edit menu</td>
    </tr>
    <tr>
      <td>Left encoder (press)</td>
      <td>Activate scale in main menu; add/remove note in scale edit menu</td>
    </tr>
    <tr>
      <td>Right encoder (turn)</td>
      <td>Navigation mode: move up and down through the menu items. Edit mode: increase or decrease the value being edited; move scale “mask” in scale edit menu</td>
    </tr>
    <tr>
      <td>Right encoder (press)</td>
      <td>Toggle between menu navigation (selection) mode and value editing mode</td>
    </tr>
    <tr>
      <td>Right encoder (long press)</td>
      <td>App selection menu</td>
    </tr>
    <tr>
      <td>Up button</td>
      <td>toggle octave up</td>
    </tr>
    <tr>
      <td>Up button (long press)</td>
      <td>screensaver shortcut</td>
    </tr>
    <tr>
      <td>Down button</td>
      <td>freeze ASR input buffer</td>
    </tr>
    <tr>
      <td>Down button (long press)</td>
      <td>toggle delay type: multiplying / basic</td>
    </tr>
  </tbody>
</table>

<h3 id="available-settings">Available settings</h3>

<table class="settings-table">
  <thead>
    <tr>
      <th>Setting</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">scale</code></td>
      <td>Current scale (active scale labelled with a little dot)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">root</code></td>
      <td>Root note for scale</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">mask</code></td>
      <td>“scale mask” / active note pattern in the selected scale</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">octave</code></td>
      <td>octave</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">buf. index</code></td>
      <td>ring buffer index (= “delay”) amount</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">hold (buflen)</code></td>
      <td>length of buffer (when freezing the ASR): <code class="highlighter-rouge">4</code> - <code class="highlighter-rouge">63</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">trigger delay</code></td>
      <td>sets the TR1-input-to-processing latency (for details see <em>Quantermain</em> below)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">input gain</code></td>
      <td>CV “gain”, multiplies incoming CV1 sample value by selected value (range: 0.05 - 2.00 in steps of 0.05). Note that this setting also affects the range of the ‘internal’ CV sources (LFSR, bytebeats and integer sequences, see below).</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CV4 dest. --&gt;</code></td>
      <td>parameter assigned to CV4 input</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CV source</code></td>
      <td>sets the source of the sample voltage, either an external voltage (CV1), or an ‘internal’ source (details see below)</td>
    </tr>
  </tbody>
</table>


	<p>This app works much the same as the original o_C / quantising <strong>ASR</strong> firmware, except that it now incorporates some of the new/improved quantiser features, including a larger selection of <strong>(editable) preset scales</strong> as well as advanced user-scale-edit and (non-1V/oct) tuning options (for details, see the <a href="http://ornament-and-cri.me/user-manual-v1_3/#quantermain">Quantermain</a> “app” below and the info re: <a href="http://ornament-and-cri.me/user-manual-v1_3/#anchor-tunings">custom scales/tunings</a> above).</p>

	<p>In essence, then, ASR mode works as a cascaded, four-stage sample-and-hold module (see <a href="http://www.cyndustries.com/synapse/synapse.cfm?pc=35&amp;folder=sept1976&amp;pic=19">here</a> for an exposition on the classic ASR implementation):</p>

	<ul>
	  <li>Feed a pulse (clock, trigger) into the left-most digital input (<strong>TR1</strong>), and a CV signal (LFO, ADSR, etc) into the leftmost CV input (<strong>CV1</strong>): on receiving a/the clock, the DAC outputs will be updated, <strong>ASR-style</strong>: the sampled value will be present at output A, the previous sample values shifted down the remaining outputs B, C, and D.</li>
	</ul>

	<ul>
	  <li>
		<p>The ASR mode features additional parameters, including</p>

		<ul>
		  <li>a <strong>delay</strong> (= controlled via the <code class="highlighter-rouge">buf. index</code> parameter (CV2))</li>
		  <li><strong>scale ‘mask’</strong> rotation (CV3)</li>
		  <li><strong>hold</strong> (which “freezes” the sample buffer) (TR2, down button)</li>
		  <li>CV over <strong>transposition</strong>, <strong>scale mask rotation</strong>, <strong>root</strong>, <strong>buffer size</strong> (assignable via CV4)</li>
		</ul>
	  </li>
	  <li>
		<p>Please also see the discussion of the <code class="highlighter-rouge">Trigger delay</code> menu selection in the <em>Quantermain</em> app documentation below — the same considerations apply to the <code class="highlighter-rouge">trigger delay</code> setting in <em>CopierMaschine</em>.</p>
	  </li>
	</ul>

	<h4 id="buffer-index-delay">buffer index (delay)</h4>

	<ul>
	  <li>
		<p>The <code class="highlighter-rouge">index</code> parameter works as a delay, sort of: internally, the ASR is a ring-buffer (buffer size = 256), and (to simplify things) by default outputs the sampled values S[x] stored at the buffer locations <strong>index * output-stage</strong>, ie A = S[i * 1], B = S[i * 2], C = S[i * 3], and D = S[i * 4].</p>
	  </li>
	  <li>
		<p>The default index setting (<code class="highlighter-rouge">buf. index</code>) is 0 (internally i = 1), in which case things boil down to standard ASR behaviour:</p>

		<p><strong>A = S[1]</strong>, <strong>B = S[2]</strong>, <strong>C = S[3]</strong>, and <strong>D = S[4]</strong></p>
	  </li>
	  <li>
		<p>If the index parameter was instead set to, say, i = 8, the ASR in that case would output the values stored in the buffer at locations S[8], S[16], S[24], and S[32], thus delaying output A by 8 clocks, B by 16 clocks, and so on. Thus, modulating the <code class="highlighter-rouge">index</code> parameter doesn’t just delay the output on channels B to D, but also allows different patterns to be created (based on the contents of the buffer).</p>
	  </li>
	  <li>
		<p><strong>Alternatively</strong>, you can change the way the delay behaves by long-pressing the down-button once. (Two little dots will appear next to the clock indicator at the top of the menu, on the right). In this case, the value of <code class="highlighter-rouge">buf. index</code> will simply be <strong>added</strong> to the buffer locations, ie A = S[1 + i], B = S[2 + i], C = S[3 + i], and D = S[4 + i]. The resulting behaviour is that of a regular delay line. Another long-press on the down button will toggle back to the first <code class="highlighter-rouge">index</code> mode.</p>
	  </li>
	</ul>

	<h4 id="hold-freeze">hold (‘freeze’)</h4>

	<ul>
	  <li>
		<p>Pressing the <strong>down button</strong> will toggle ‘freeze’ mode. Freeze mode is also activated while the  TR2 (= hold) input is held <strong>high</strong> (using a gate or the like). In freeze mode, <strong>no further samples will be acquired</strong>; when clocked, the four outputs then simply cycle through what’s already the buffer. If ‘freeze’ is engaged, two little dots will appear next to the scale name, at the top of the menu, indicating the buffer is currently frozen.</p>
	  </li>
	  <li>
		<p>The size of the hold buffer is determined by the <code class="highlighter-rouge">hold (buflen)</code> parameter, which goes from 4 to 63. While the buffer is ‘frozen’, all the various modulation options (buffer length, transposition, scale change, etc) are still available / operate on the frozen buffer contents.</p>
	  </li>
	  <li>
		<p>‘Freeze’ mode effectively turns <em>CopierMaschine</em> into a clocked, quantised CV recorder, with four output taps and variable playback parameters.</p>
	  </li>
	</ul>

	<h3 id="inputs-and-outputs">Inputs and outputs</h3>



	<h3 id="scale-edit">Scale edit:</h3>

	<p>see <a href="http://ornament-and-cri.me/user-manual-v1_3/#active-note-scale-mask-and-scale-editing">here</a> (user-scales are shared across apps).</p>

	<h3 id="screensaver-display">Screensaver display</h3>

	<p>Four little “Arabesque” patterns, representing the pitch CV output on each of the four channels.</p>

	<h3 id="cv-sources">CV sources</h3>

	<p>Four settings of the <code class="highlighter-rouge">CV source</code> parameter are available:</p>

	<ul>
	  <li><code class="highlighter-rouge">CV1</code> — voltages on the CV1 input are quantised, according to the <code class="highlighter-rouge">scale</code> and <code class="highlighter-rouge">Active notes</code> settings.</li>
	  <li><code class="highlighter-rouge">LFSR</code> — “Linear Feedback Shift register” (also referred to as a “Turing Machine” or “TM” elsewhere in this documentation). This is the same as the <code class="highlighter-rouge">Turing</code> source in the <em>Quantermain</em> app - please see the discussion of the Turing Machine source in the <em>Quantermain</em> section for further details of operation. The available settings for the Turing Machine source in <em>CopierMaschine</em> are shown in the table below.</li>
	  <li><code class="highlighter-rouge">ByteB</code> — “bytebeat” equations used to generate semi-fractal note values, rather than audio signals (which is what byte beat equations are usually used for). Please see the <em>Viznutcracker, sweet!</em> app for details of the byte beat equations available.</li>
	  <li><code class="highlighter-rouge">IntSq</code> — integer sequences - several classes of random and fractal integer sequences, used as note values.</li>
	</ul>


<h3 id="lfsr-source-settings-in-copiermaschine">LFSR source settings in <em>CopierMaschine</em></h3>

<p>Note: <code class="highlighter-rouge">LFSR</code> is used equivalently to “Turing Machine” here. (see <em>Quantermain</em> for details).</p>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">LFSR length</code></td>
      <td>Length of the linear feedback shift register, in bits, range 4 to 32</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">LFSR p</code></td>
      <td>Probability that the least significant bit will be flipped when it to copied, range 0 to 255 (0 means <em>p</em>= 0, 255 means <em>p</em>= 1)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">LFSR CV1</code></td>
      <td>The Turing Machine parameter to which any voltage input on CV1 will be directed. Choices are <code class="highlighter-rouge">rng</code>, <code class="highlighter-rouge">len</code> and <code class="highlighter-rouge">p</code> (ie, range, length, and probability)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Note that the <code class="highlighter-rouge">LFSR range</code> setting in previous versions has been subsumed by the <code class="highlighter-rouge">input gain</code> setting, which now also affects the ‘internal’ CV sources such as LFSR, bytebeats and integer sequences.</td>
    </tr>
  </tbody>
</table>

<h3 id="byte-beats-source-settings-in-copiermaschine">Byte beats source settings in <em>CopierMaschine</em></h3>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">BB eqn</code></td>
      <td>sets the byte beat equation used as the source. See the <em>Viznutcracker, sweet!</em> app documentation for more details of the currently available equations.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">BB P0</code></td>
      <td>Parameter 0 for the byte beat equation - see See the <em>Viznutcracker, sweet!</em> app documentation for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">BB P1</code></td>
      <td>Parameter 1 for the byte beat equation - see See the <em>Viznutcracker, sweet!</em> app documentation for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">BB P2</code></td>
      <td>Parameter 2 for the byte beat equation - see See the <em>Viznutcracker, sweet!</em> app documentation for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">BB CV1</code></td>
      <td>The byte beat parameter to which the input on CV1 is directed. Possible destinations are “igain” (input gain), “eqn” (equation), “P0”, “P1”, “P2”. See <code class="highlighter-rouge">LFSR CV1</code> above for details of input voltage ranges.</td>
    </tr>
  </tbody>
</table>

<p>Note that compared to the bytebeat source in <em>Quantermain</em>, the <code class="highlighter-rouge">Bytebeat range</code> parameter is missing from <em>CopierMaschine</em>. The reason is that the <code class="highlighter-rouge">input gain</code> setting has the same effect in <em>CopierMaschine</em> when the <code class="highlighter-rouge">ByteB</code> source is used as the <code class="highlighter-rouge">Bytebeat range</code> setting does in <em>Quantermain</em>.</p>

<h3 id="integer-sequence-source-settings-in-copiermaschine">Integer sequence source settings in <em>CopierMaschine</em></h3>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">IntSeq</code></td>
      <td>sets the integer sequence used as the source. See below for a list of available integer sequences and their characteristics.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntSeq modul</code></td>
      <td>sets the modulus for the integer sequence. The value of the integer from the integer sequence is divided by the modulus and the remainder is used. For example, if the modulus is 8 and the current integer value from the sequence is 19, then the remainder of 19 - (2 x 8) i.e. 3 is used as the value. In other words, values “wrap around” at the modulus setting — it sets a maximum note range for the integer sequence, similarly to the <code class="highlighter-rouge">M/A</code> setting, but <code class="highlighter-rouge">M/A</code> compresses of expands the range of notes for a given integer value from the sequence, whereas the modulus wraps the values around.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntSeq start</code></td>
      <td>sets the start point in the stored integer sequence. The stored sequences are 128 steps long, and the maximum start point is 126 to ensure a minimum sequence length of 2.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntSeq len</code></td>
      <td>sets the length of the integer sequence. Thus a length of 16 will use just 16 values from the stored 128 step sequence, starting at the step specified by <code class="highlighter-rouge">IntSeq start</code>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntSeq dir</code></td>
      <td>sets whether the integer sequence loops back to the beginning when it gets to the end, or whether it swings back like a pendulum and plays in reverse when it reaches the end. The “end” is the last step in the sequence, as defined by the sequence start plus the sequence length settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Fractal stride</code></td>
      <td>Several of the sequences are fractal or semi-fractal in nature (i.e. they are self-similar), and the “stride” setting sets how many steps are advanced on each trigger input. This also works well with the non-fractal sequences and provides additional variation, particularly if the stride is not an exact divisor of the sequence length.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">IntSeq CV1</code></td>
      <td>The integer sequence parameter to which the input on CV1 is directed. Possible destinations are (parameter names in brackets): <code class="highlighter-rouge">M/A</code> (mult/att), <code class="highlighter-rouge">seq</code> (IntSeq), <code class="highlighter-rouge">strt</code> (IntSeq start), <code class="highlighter-rouge">len</code> (IntSeq len), <code class="highlighter-rouge">strd</code> (Fractal stride) and <code class="highlighter-rouge">mod</code> (IntSeq modul). See <code class="highlighter-rouge">LFSR CV1</code> above for details of input voltage ranges.</td>
    </tr>
  </tbody>
</table>

<h4 id="integer-sequences-available-in-copiermaschine-and-quantermain">Integer sequences available in <em>CopierMaschine</em> and <em>Quantermain</em></h4>

<table>
  <thead>
    <tr>
      <th>Menu name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">pi</code></td>
      <td>The first 128 digits of <a href="https://en.wikipedia.org/wiki/Pi">π</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vnEck</code></td>
      <td>The first 128 integers in <a href="https://oeis.org/A181391">van Eck’s sequence</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ssdn</code></td>
      <td>The first 128 integers in the <a href="https://oeis.org/A003132">sequence of the sum of squares of the digits of <em>n</em></a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Dress</code></td>
      <td><a href="https://oeis.org/A001316">Dress’s sequence</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PNinf</code></td>
      <td><a href="http://www.pernoergaard.dk/eng/strukturer/uendelig/ukonstruktion03.html">Per Nørgård’s infinity series</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Dsum</code></td>
      <td><a href="https://oeis.org/A007953">Digital sum (i.e. sum of digits) of <em>n</em>; also called digsum(n)</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Dsum4</code></td>
      <td><a href="https://oeis.org/A053737">Digital sum (i.e. sum of digits) of <em>n</em> written in base 4</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Dsum5</code></td>
      <td><a href="https://oeis.org/A053824">Digital sum (i.e. sum of digits) of <em>n</em> written in base 5</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CDn2</code></td>
      <td><a href="https://oeis.org/A122196">Fractal sequence: count down by 2’s from successive integers</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Frcti</code></td>
      <td><a href="https://oeis.org/A163256">Fractal sequence of the interspersion A163253</a>.</td>
    </tr>
  </tbody>
</table>

<p>See the acknowledgements section for additional references for some of these integer sequences.</p>

<p>Note that there isn’t really anything magical or mystical about the digits of transcendental numbers such as π — they are just a convenient source of sequences of digits. However, if you use them to make music, then you can post videos like <a href="https://www.youtube.com/watch?v=YOQb_mtkEEE">this</a>, or <a href="https://www.youtube.com/watch?v=OMq9he-5HUU">this</a>. The fractal and semi-fractal sequences can produce some magical melodies, however.</p>
</div>
</div>
</div>
</body>